# Mysql的学习
> * 一条sql（查询,更新）是怎么执行的
> * 事务隔离
> * 索引


## 1 一条sql查询是怎么执行的
```
select * from test where id = 1;
```
![cmd-markdown-logo](https://github.com/MyApe/blogs/blob/master/mysql1.png)

MySQL大体可以分为serve层和数据引擎层
serve层包括连接器，数据缓存，分析器，优化器，执行器等，涵盖了大多数MySQL的核心服务功能，
以及所有的内置函数(日期，时间等)，并且所有跨数据引擎的都这serve层实现，比如存储过程，触发器，视图等
而数据引擎层负责数据存储和提取，支持InnoDB,MyISAM,Memory等，其中常用的支持InnoDB在5.5.5后开始成为默认的
数据引擎
### 连接器
第一步就是连接到mysql的客户端。这是连接器就会跟客户端建立连接，获取权限
维持和管理连接。连接命令一般如下
```
mysql -hlocalhost -uroot -p
```
### 查询缓存
建立完连接，在没有设置取消缓存的情况下，先会到查询缓存看看，如果命中，则会直接返回结果
而没有命中的情况下则会继续执行逻辑。
但是，绝大多数情况下，都会不使用缓存，混存的使用往往弊大于利。还有就是，缓存失效非常频繁。(8.0以后版本取消了查询缓存)
### 分析器
在缓存没有命中的情况下，开始真正执行sql了。首先，MySQL需要知道你要干什么，因此会对sql进行解析。
MySQL会从"select"中识别出，这是一个查询语句。会把"test"识别为表test，"id"识别为“列id”，在然后
就会判断输入的SQL是否符合语法规范。
### 优化器
在经过分析器之后，MySQL已经知道，你要干什么了。在执行之前还需要执行优化器处理。
在执行优化器时，MySQL会决定用哪个索引；或者在多个表关联时，决定表的连接顺序
比如下列语句
```
select * from  t1 join  t2 where using(id) t1.c = 10 and t2.d = 20 ;

```
既可以先取到t1表里c=10的值，再根据id关联到t2，判断d的值是否等于20
也可以先取表t2里d=20的值，根据id关联，判断表t1的c列值是否等于10
这两个执行方法的逻辑是相同的，但是效率是不同的，而优化器就是根据它来选择出使用哪种方案

### 执行器
MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。
开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。
查询也会在优化器之前调用 precheck 验证权限

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这 个引擎提供的接口。
比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
至此，这个语句就执行完成了。
对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中 扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。
在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。

**question：**当查询语句中的列名错误时，MySQL会在那一阶段就报错



















*MYSQL会在分析阶段判断语句是否正确，表是否存在，列是否存在等*
















## 1 一条sql更新是怎么执行的
这里 新建表T  主键key  插入一条语句，在修改值
```
create table T(ID int primary key, c int);
insert into T values(1,0);
update T set c=c+1 where ID=1;
```
首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会 走一遍。
在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句 就会把表 T 上所有缓存结果都清空。这也就是一般不建议使用查询缓存的原因。

接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个 索引。然后，执行器负责具体执行，找到这一行，然后更新
与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。
### 重要的日志模块：redo log
MySQL在数据更新时会遇到一个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。
为了解决这个 问题，MySQL 的设计者就用了类似记账的思路来提升更新效率。
其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称 是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。
同时，InnoDB 引擎会在适当的时候， 将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
有了redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢 失，这个能力称为crash-safe
### 重要的日志模块：binlog
MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。
redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。

因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。
而 InnoDB 是另一个公司 以插件形式引入MySQL 的，既然只依靠binlog是没有crash-safe 能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。
这两种日志有以下三点不同。
1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都 可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=1 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。
1. 执行器先找引擎取 ID=1 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log 里面，此时redo log 处于prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状 态，更新完成。
图中浅色框表示是在 InnoDB 内部执行的， 深色框表示是在执行器中执行
![cmd-markdown-logo](https://github.com/MyApe/blogs/blob/master/docs/mysql2.png)
redo log的提交具有两阶段，以下从反面解释了为什么两阶段
1. 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候， MySQL 进程异常重启。
   redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 
   但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此， 
   之后备份日志的时候，存起来的 binlog 里面就没有这条语句。
   然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢 失，
   这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，
   崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，
   在之后用 binlog 来恢复的时候就多了一个事务出来， 恢复出来的这一行 c 的值就是 1，与原库的值不同。



## 隔离性与隔离级别
SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化 （serializable ）
读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 索引
索引的出现其实就是为了提高数据查询的效率。
### 常见的索引模型
索引的出现是为了提高查询效率，但是实现索引的方式却有很多种。
三种常见、也比 较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key， 就可以找到其对应的值即 Value。
哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。
不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时 对应的哈希索引的示意图如下所示：

























